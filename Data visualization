import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#1.Make a heatmap of the value of the Goldstein–Price function
def plot_goldstein_price():
    # Define Goldstein–Price function
    def goldstein_price(x1, x2):
        term1 = (1 + ((x1 + x2 + 1)**2) * (19 - 14*x1 + 3*x1**2 - 14*x2 + 6*x1*x2 + 3*x2**2))
        term2 = (30 + ((2*x1 - 3*x2)**2) * (18 - 32*x1 + 12*x1**2 + 48*x2 - 36*x1*x2 + 27*x2**2))
        return term1 * term2
    # Compute the values for the grid
    x1 = np.linspace(-2, 2, 1000)
    x2 = np.linspace(-2, 2, 1000)
    X1, X2 = np.meshgrid(x1, x2)
    Z = goldstein_price(X1, X2)
    # Plot the heatmap
    plt.figure(figsize=(8, 6))
    ax = sns.heatmap(Z, cbar_kws={'label': 'Value'})
    tick_positions = np.linspace(0, len(x1) - 1, 5)
    tick_labels = [-2, -1, 0, 1, 2]
    ax.set_xticks(tick_positions)
    ax.set_xticklabels(tick_labels)
    ax.set_yticks(tick_positions)
    ax.set_yticklabels(tick_labels)
    plt.title("Heatmap of the Goldstein–Price Function")
    plt.xlabel('X1')
    plt.ylabel('X2')
    plt.show()
#2.The Goldstein–Price function is not stationary.
# Its values vary dramatically throughout its domain, characterized by regions of sharp peaks.
# Regions with high function values are near (x1,x2)=(-2,2) or (2,-2), where the function will have a very high value.
#That is, the behavior of the function appears not to be constant throughout the domain
#3.Can you find a transformation of the data that makes it more stationary?
#Picheny et al. (2012) use the following logarithmic form of the Goldstein-Price function, on [0, 1]**2
# Define the transformed Goldstein–Price function
def plot_transformed_goldstein_price():
    # Define the transformed Goldstein–Price function
    def transformed_goldstein_price(x1, x2):
        x1_scaled = 4 * x1 - 2
        x2_scaled = 4 * x2 - 2
        term1 = (1 + (x1_scaled + x2_scaled + 1)**2 *
        (19 - 14 * x1_scaled + 3 * x1_scaled**2 - 14 * x2_scaled + 6 * x1_scaled * x2_scaled + 3 * x2_scaled**2))
        term2 = (30 + (2 * x1_scaled - 3 * x2_scaled)**2 *
        (18 - 32 * x1_scaled + 12 * x1_scaled**2 + 48 * x2_scaled - 36 * x1_scaled * x2_scaled + 27 * x2_scaled**2))
        log_transformed = np.log(np.maximum(term1 * term2 - 8.693, 1e-8))
        return log_transformed / 2.427
    x1 = np.linspace(-2, 2, 1000)
    x2 = np.linspace(-2, 2, 1000)
    X1, X2 = np.meshgrid(x1, x2)
    Z_transformed = transformed_goldstein_price(X1, X2)
    # Plot the heatmap for the transformed function
    plt.figure(figsize=(8, 6))
    ax = sns.heatmap(Z_transformed, cbar_kws={'label': 'Transformed Value'})
    tick_positions = np.linspace(0, len(x1) - 1, 5)
    tick_labels = [-2,-1,0,1,2]
    ax.set_xticks(tick_positions)
    ax.set_xticklabels(tick_labels)
    ax.set_yticks(tick_positions)
    ax.set_yticklabels(tick_labels)
    plt.title("Heatmap of the Transformed Goldstein–Price Function")
    plt.xlabel('X1')
    plt.ylabel('X2')
    plt.show()
#3D plot (to test the correctness of the function)
# def transformed_goldstein_price(x1, x2):
#     term1 = (1 + (x1 + x2 + 1)**2 *
#                  (19 - 14 * x1 + 3 * x1**2 - 14 * x2 + 6 * x1 * x2 + 3 * x2**2))
#     term2 = (30 + (2 * x1 - 3 * x2)**2 *
#                  (18 - 32 * x1 + 12 * x1**2 + 48 * x2 - 36 * x1 * x2 + 27 * x2**2))
#     log_transformed = np.log(np.maximum(term1 * term2 - 8.693, 1e-8))
#     return log_transformed / 2.427
# x1 = np.linspace(-2, 2, 200)
# x2 = np.linspace(-2, 2, 200)
# X1, X2 = np.meshgrid(x1, x2)
# Z_transformed = transformed_goldstein_price(X1, X2)
# fig = plt.figure(figsize=(10, 8))
# ax = fig.add_subplot(111, projection='3d')
# ax.plot_surface(X1, X2, Z_transformed, cmap="viridis", edgecolor="k", alpha=0.8)
# ax.set_title("3D Plot of the Transformed Goldstein–Price Function")
# ax.set_xlabel("X1")
# ax.set_ylabel("X2")
# ax.set_zlabel("Transformed Value")
# plt.show()
#4.Make a kernel density estimate of the distribution of the values for the lda and svm benchmarks

if __name__ == "__main__":
    plot_goldstein_price()
    plot_transformed_goldstein_price()
